---
title: "Next.js 렌더링 전략"
date: 2025-06-24
categories: [Frontend, Next.js]
tags: [nextjs, rendering, react, ssr, csr, ssg]
layout: post
---

## Next.js 렌더링 전략
> Next.js는 크게 **클라이언트 사이드 렌더링(CSR)**, **서버 사이드 렌더링(SSR)**, **정적 사이트 생성(SSG)**, 그리고 **점진적 정적 생성(ISR)**의 네 가지 렌더링 전략을 제공합니다
{: .prompt-tip}

프로젝트를 들어가기 전 각 페이지마다 어떤 렌더링 전략을 취하면 좋을지 판단하기 위해 네가지의 렌더링 전략을 다시 한번 정리해보려 합니다.


### Next.js 렌더링 전략 선택 기준

Next.js의 렌더링 전략을 선택할 때는 애플리케이션의 특정 페이지나 컴포넌트의 특성을 고려하는 것이 중요합니다.

1.  **SEO (검색 엔진 최적화)의 중요성**
    * Google, Naver 등 검색 엔진에 페이지 내용이 잘 노출되어야 한다면, 크롤러가 HTML을 쉽게 파싱할 수 있는 전략이 유리하다.
2.  **데이터의 변경 빈도**
    * 콘텐츠가 거의 변하지 않는 정적인 페이지인가?
    * 자주 업데이트되지만 실시간으로 반영될 필요는 없는 페이지인가?
    * 매우 동적이고 실시간으로 최신 데이터가 반영되어야 하는 페이지인가?
3.  **초기 로딩 속도 (First Contentful Paint, FCP)의 중요성**
    * 사용자가 가능한 한 빨리 페이지의 내용을 볼 수 있어야 하는가?
4.  **서버에 가해지는 부하**
    * 사용했을때 서버 부하의 정도
5.  **사용자별 개인화된 콘텐츠**
    * 로그인 사용자에게만 보여지는 정보나, 사용자 설정에 따라 달라지는 내용이 많은가?

---

### 선택 기준에 따른 전략 평가

그럼 위 선택 기준에 따라 Next.js의 주요 렌더링 전략들을 알아보겠습니다. 

#### 1. 정적 사이트 생성 (Static Site Generation, SSG)

> SSG는 애플리케이션 **빌드 시점**에 페이지의 HTML을 미리 생성하여 저장하는 방식이다. 이렇게 생성된 정적 HTML 파일들은 CDN에 배포되어 사용자 요청 시 즉시 제공된다.
{: .prompt-info }

* **선택 기준:**
    * **SEO:** ⭐⭐⭐⭐⭐ (매우 중요)
    * **데이터 변경 빈도:** 거의 변경되지 않음
    * **초기 로딩 속도:** ⭐⭐⭐⭐⭐ (매우 빠름)
    * **서버 부하:** ⭐⭐⭐⭐⭐ (거의 없음)
    * **개인화:** ❌ (어려움)

* **예시 페이지**
    * **소개 페이지**
    * **블로그 포스트**


* **Next.js에서의 구현 (예시):**
    * **Pages Router:** `getStaticProps` 함수를 사용하고 동적 경로(`posts/[id].tsx`)의 경우, `getStaticPaths` 함수를 함께 사용해 빌드할 경로 목록을 정의한다.
    * **App Router:** 서버 컴포넌트(`app/page.tsx`)가 기본적으로 SSG처럼 동작한다. 서버 컴포넌트 내에서 `fetch` API를 호출하면 빌드 시에 데이터를 가져와 정적 파일을 생성합니다.

#### 2. 점진적 정적 생성 (Incremental Static Regeneration, ISR)

> ISR은 SSG의 장점(빠른 성능, SEO 유리)을 유지하면서, 콘텐츠가 업데이트되었을 때 **전체 애플리케이션을 재빌드하지 않고도** 특정 페이지를 주기적으로 또는 요청 시에 업데이트할 수 있는 방식이다. 처음에 캐시된 페이지를 보여주다가, 백그라운드에서 페이지를 업데이트하고 다음 요청부터 최신 페이지를 렌더링한다.
{: .prompt-info }


* **선택 기준:**
    * **SEO:** ⭐⭐⭐⭐ (중요)
    * **데이터 변경 빈도:** 변경은 되지만 실시간 반영은 불필요 (예: 뉴스 기사, 블로그)
    * **초기 로딩 속도:** ⭐⭐⭐⭐ (빠름)
    * **서버 부하:** ⭐⭐⭐⭐ (적음)
    * **개인화:** ❌

* **예시 페이지:**
    * **뉴스 기사 목록** 
    * **이벤트/프로모션 페이지** 이벤트가 실시간이 아니라 일정 시간마다 업데이트 되는 경우
    * **댓글 수가 많은 블로그 포스트** 댓글은 동적이므로, 일정 시간마다 댓글을 재검증하여 업데이트할 수 있다.

* **Next.js에서의 구현 (예시):**
    * **Pages Router:** `getStaticProps` 함수 내에 `revalidate` 옵션을 추가하여 특정 시간마다 페이지를 재검증하도록 설정한다.
    * **App Router:** `fetch` API 호출 시 `revalidate` 옵션으로 특정 시간마다 데이터를 다시 가져오도록 설정하거나, `revalidateTag` 함수를 통해 특정 캐시 태그를 가진 데이터를 수동으로 재검증할 수 있다.

#### 3. 서버 사이드 렌더링 (Server-Side Rendering, SSR)

> SSR은 사용자 요청이 있을 때마다 웹 서버가 페이지의 HTML을 실시간으로 생성하여 클라이언트로 전송하는 방식이다. 브라우저는 이미 완성된 HTML을 받기 때문에 빠르게 페이지를 표시할 수 있다.
{: .prompt-info }


* **선택 기준:**
    * **SEO:** ⭐⭐⭐⭐ (중요)
    * **데이터 변경 빈도:** 매우 동적이며 실시간 반영 필요
    * **초기 로딩 속도:** ⭐⭐⭐ (보통)
    * **서버 부하:** ⭐⭐ (많음)
    * **개인화:** ⭐⭐⭐⭐ (유리)

* **예시 페이지:**
    * **쇼핑몰 장바구니/주문 페이지:** 사용자별로 내용이 완전히 다르며 실시간으로 변경되는 경우
    * **마이페이지:** 로그인한 사용자마다 다른 데이터(예: 주문 내역, 알림)를 보여줘야 하는 경우.
    * **검색 결과 페이지:**
    * **실시간 재고 현황 페이지:** 재고량이 실시간으로 변동하는 경우

* **Next.js에서의 구현 (예시):**
    * **Pages Router:** `getServerSideProps` 함수를 사용하여 페이지 컴포넌트의 데이터를 서버에서 가져와 렌더링한다.
    * **App Router:** 서버 컴포넌트(`app/page.tsx` 등)가 기본적으로 SSR처럼 동작할 수 있다. `fetch` API를 서버 컴포넌트 내에서 호출할 때 `cache: 'no-store'` 옵션을 사용하거나, `cookies()` 또는 `headers()`와 같은 동적 함수를 사용하면 해당 컴포넌트는 요청 시마다 서버에서 렌더링된다.

#### 4. 클라이언트 사이드 렌더링 (Client-Side Rendering, CSR)

> CSR은 웹 브라우저(클라이언트)가 JavaScript 코드를 다운로드하고 실행하여 웹 페이지의 내용을 렌더링하는 방식이다. 초기에는 비어있는 HTML 파일과 JavaScript 번들만 다운로드되고, JavaScript가 실행된 후에야 콘텐츠가 화면에 표시된다. 로그인 후에만 접근 가능한 대시보드나 관리자 페이지처럼 SEO가 중요하지 않은 페이지에 주로 사용된다.
{: .prompt-info }

* **선택 기준:**
    * **SEO:** ⭐⭐ (덜 중요)
    * **데이터 변경 빈도:** 매우 동적, 로그인 후 콘텐츠
    * **초기 로딩 속도:** ⭐⭐ (느림)
    * **서버 부하:** ⭐⭐⭐⭐ (적음)
    * **개인화:** ⭐⭐⭐⭐⭐ (매우 유리)

* **예시 페이지:**
    * **관리자 페이지/대시보드:** SEO가 중요하지 않고, 사용자 인터랙션이 많으며, 데이터를 동적으로 업데이트하는 데 중점을 둔다.
    * **댓글/채팅 위젯:** 페이지의 주 콘텐츠와 별개로 실시간 상호작용이 필요한 경우.
    * **싱글 페이지 애플리케이션 (SPA):** 초기 로드 후 페이지 전환이 빠르고, 복잡한 클라이언트 측 상태 관리가 필요한 경우.

* **Next.js에서의 구현 (예시):**
    * **Pages Router:** `useEffect` 훅 내에서 데이터를 가져오거나, `swr` 또는 `react-query` 같은 클라이언트 측 데이터 페칭 라이브러리를 사용하여 데이터를 렌더링한다.
    * **App Router:** `use client` 지시어를 포함한 클라이언트 컴포넌트 내에서 `useEffect` 또는 클라이언트 측 데이터 페칭 라이브러리를 사용한다.
