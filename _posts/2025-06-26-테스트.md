---
title: "프론트엔드 테스트"
date: 2025-06-26 
categories: [Frontend, Testcode]
tags: [frontend, testcode]
layout: post
---


## 프론트엔드 테스트란?

> 프론트엔드 테스트는 웹 애플리케이션의 사용자 인터페이스(UI)와 사용자 경험(UX)이 개발자의 의도대로, 그리고 사용자의 기대에 부합하게 작동하는지 검증하는 일련의 과정이다.
{: .prompt-info }


## ✅ 프론트엔드 테스트의 중요성

*   **품질 및 신뢰성 향상**: 버그를 조기에 발견하고 수정함으로써, 제품의 품질을 높이고 애플리케이션의 신뢰성을 확보해준다.
*   **유지보수성 증대**: 코드 변경이나 기능 추가 시 기존 기능이 손상되지 않음을 테스트가 보장해준다. 
*   **개발 생산성 향상**: 테스트 스위트가 잘 구축되어 있으면, 개발자는 자신의 코드 변경이 다른 부분에 미칠 영향을 빠르게 파악할 수 있어 생산성 향상에 효과적이다.

## 📰 프론트엔드 테스트의 종류

여기서는 대표적인 세가지의 테스트를 다룬다

### 단위 테스트 (Unit Tests)
*   애플리케이션의 가장 작은 독립적인 코드 단위(함수, 컴포넌트의 개별 로직, 유틸리티 등)를 테스트한다.
*   버그 발생 시 **문제의 원인**을 정확히 파악하기 용이하다.
*   **주요 도구**: Jest, Vitest, React Testing Library (컴포넌트 단위 테스트 시)

### 통합 테스트 (Integration Tests)
*   여러 단위 또는 컴포넌트가 함께 작동할 때의 상호작용과 데이터 흐름을 테스트한다. (예: 컴포넌트와 API 호출 로직의 결합)
*   컴포넌트 간의 연결이 올바르게 이루어지고, 함께 작동할 때 문제가 없는지 확인한다.
*   시스템의 특정 부분들이 잘 연동되는지 검증한다.
*   **주요 도구**: React Testing Library, Jest, Vitest

### 종단 간 테스트 (End-to-End / E2E Tests)
*   실제 사용자가 애플리케이션을 사용하는 시나리오대로, 처음부터 끝까지 전체 시스템의 흐름을 테스트한다. 
 (예: 회원가입 -> 로그인 -> 상품 검색 -> 장바구니 추가 -> 결제 완료)
* 전체 애플리케이션이 **사용자 관점**에서 기대하는 기능을 완벽하게 수행하는지 검증한다.
*   설정 및 유지보수가 복잡하고, 실행 속도가 느릴 수 있다.
*   **주요 도구**: Cypress, Playwright, Selenium

---

## 🎯 좋은 테스트 코드를 위한 규칙
또한 테스트 코드를 작성할 때에는 따라야할 여러가지 규칙이 있다.

### 1. FIRST 원칙

#### **Fast**
테스트는 빨라야 합니다. 테스트 실행 시간이 길어지면 개발자들은 코드 변경 시마다 테스트를 실행하는 것을 꺼리게 되고, 결국 테스트는 방치됩니다. 빠른 테스트는 개발 흐름을 끊지 않고, 코드 수정 후 즉각적인 피드백을 제공하여 생산성을 높인다.

* **실천 방안**:
    * 무거운 프레임워크나 라이브러리를 로드하지 않는 순수한 단위 테스트에 집중한다.

#### **Independent / Isolated**
각 테스트 케이스는 서로 완전히 독립적이어야 한다. 한 테스트의 결과가 다른 테스트에 영향을 주어서는 안 되며, 어떤 순서로 실행되더라도 항상 동일한 결과를 보장해야 한다.

* **실천 방안**:
    * 각 테스트(`it` 블록)가 시작되기 전에 `beforeEach`를 사용하여 상태를 초기화하고, 끝난 후에 `afterEach`를 사용하여 생성된 데이터를 정리합니다.
    * 테스트 간에 전역 변수나 외부 모듈의 상태를 공유하지 않는다.

#### **Repeatable**
테스트는 어떤 환경(로컬 개발 머신, 동료의 컴퓨터, CI/CD 서버 등)에서도, 언제 실행하더라도 항상 동일한 결과를 내야 합니다. 결과가 환경에 따라 달라진다면 테스트의 신뢰도는 급격히 떨어진다

* **실천 방안**:
    * 현재 날짜/시간, 랜덤 값, 외부 API 응답 등 변동 가능성이 있는 외부 요소를 **직접** 사용하지 않고, 테스트 중에는 고정된 값을 반환하도록 제어한다.

#### **Self-Validating**
테스트는 실행 결과(성공 또는 실패)를 스스로 판단하고 명확하게 알려주어야 한다. 개발자가 로그 파일을 직접 열어보거나 콘솔 출력을 수동으로 확인해야만 결과를 알 수 있다면 좋은 테스트가 아니다.

* **실천 방안**:
    * `expect`와 같은 단언(Assertion) 라이브러리를 사용하여 테스트의 마지막에 결과를 명시적으로 검증한다.
    * 테스트 결과는 `PASS` 또는 `FAIL`로 명확하게 출력되어야 한다.

#### **Timely / Thorough**
* **시기적절하게(Timely)**: 테스트는 프로덕션 코드를 작성하기 직전, 또는 동시에 작성하는 것이 가장 이상적이다(**TDD**). 이를 통해 테스트가 프로덕션 코드의 설계를 주도하게 되며, 테스트 가능한 구조를 자연스럽게 만들 수 있다.
* **철저하게(Thorough)**: 테스트는 단순히 성공적인 시나리오뿐만 아니라 오류 상황, 예외적인 입력값, 경계값(예: 0, -1, null, 빈 배열) 등 다양한 **엣지 케이스(Edge Case)**를 철저하게 검증해야 한다.

### 2. 가독성과 구조화

테스트 코드도 프로덕션 코드만큼이나 **읽기 쉬워야** 한다.

* **Arrange-Act-Assert (AAA) 패턴 사용**: 테스트 코드를 '준비-실행-검증'의 세 단계로 구조화하면 테스트의 의도를 명확하게 파악할 수 있다.
    ```typescript
    it('배열에 음수가 포함된 경우에도 최댓값을 올바르게 반환해야 한다', () => {
      // 1. Arrange (준비)
      const numbers = [-5, -1, -10, -3];
      const expected = -1;

      // 2. Act (실행)
      const result = getMax(numbers);

      // 3. Assert (검증)
      expect(result).toBe(expected);
    });
    ```
* **서술적인 테스트 이름**: `it('테스트 1')`과 같은 이름 대신 `it('배열에 음수가 포함된 경우에도 최댓값을 올바르게 반환해야 한다')`처럼 테스트의 목적과 기대 결과를 명확하게 설명하는 이름을 사용해야 한다.


### 3. 테스트 케이스 당 하나의 단언

하나의 `it` 블록은 **논리적으로 하나의 개념**만 검증해야 한다. 이는 "하나의 테스트 케이스는 하나의 실패 이유만 가져야 한다"는 의미와 같다. 테스트가 실패했을 때, 그 원인이 무엇인지 즉시 파악할 수 있기 때문이다.

* **나쁜 예**: 하나의 테스트에서 사용자의 생성, 수정, 삭제를 모두 검증하는 경우.
* **좋은 예**: `사용자 생성 테스트`, `사용자 정보 수정 테스트`, `사용자 삭제 테스트`를 각각 별개의 `it` 블록으로 분리한다.


### 4. 테스트 코드에 로직(Logic) 넣지 않기

테스트 코드 내부에 `if`, `for`, `while`과 같은 조건문이나 반복문을 사용하지 않는 것이 좋다.  
테스트 코드 자체에 로직이 들어가면, 그 로직에 버그가 생길 수 있고 이는 테스트의 신뢰성을 떨어뜨린다. 테스트는 최대한 단순하고 직설적이어야 한다.


### 5. 프로덕션 코드 수정하지 않기

테스트를 용이하게 하기 위해 프로덕션 코드를 수정하는 것은 피해야 한다. 테스트는 실제 사용될 코드를 그대로 검증해야 의미가 있다.  
코드가 테스트하기 어렵다면, 이는 테스트의 문제가 아니라 코드의 설계가 잘못되었을 가능성이 높다는 신호이다.

---
## 🛠️ 테스트 코드 작성 실습
### Jest를 사용한 단위 테스트의 기본적인 구조
``` ts
describe("add 함수", () => { 
//테스트 케이스를 작성하는 부분
    it("두 양수를 더하면 올바른 결과를 반환한다", () => { 
      // 테스트 로직을 여기에 작성한다.
      // it의 첫번째 파라미터로는 이 기능이 작동해야하는 방식을 설명한다

      // Arrange (준비): 테스트에 필요한 데이터 준비
      const a = 5;
      const b = 3;
      const expected = 8;

      // Act (실행): 테스트하고자 하는 함수 실행
      const result = add(a, b);

      // Assert (검증): 결과가 예상과 일치하는지 확인
      expect(result).toBe(expected);
    });

});
```
또는 `test("",()=>{})` 함수를 사용하기도한다.

- **describe** : 관련된 테스트들을 하나의 그룹으로 묶는 역할
- **it()** : 개별적인 하나의 테스트 케이스

여기서 사용된 테스트 패턴은 Arrange-Act-Assert (AAA 패턴)이다.

- **Arrange** : 테스트를 실행하기 위해 필요한 초기 데이터를 세팅하는 단계
- **Act** : 테스트하려는 실제 코드를 실행하는 단계
- **Assert** : 테스트 결과를 검증하는 단계
   - 예시: `expect(result).toBe(expected);`  
   Jest의 expect 함수를 사용하여 result 값이 처음에 준비했던 expected 값과 같은지 검증한다.

### Jest 익스텐션

> VS Code 마켓플레이스에서 [Jest](https://marketplace.visualstudio.com/items?itemName=Orta.vscode-jest) 익스텐션을 설치하면 코드 편집기 내에서 각 테스트를 간편하게 실행하고, 성공/실패 여부를 시각적으로 확인할 수 있어 편리하다.
{: .prompt-tip }

처음 jest 익스텐션을 설치하고 run 버튼을 클릭하면  이러한 오류가 날 수 있는데  
```
testPathPattern:

  Option "testPathPattern" was replaced by "--testPathPatterns". "--testPathPatterns" is only available as a command-line option.
  
  Please update your configuration.

  CLI Options Documentation:
  https://jestjs.io/docs/cli

```

이건 Jest extension이 기본적으로 jest@29버전을 사용하기 때문이다.
Ctrl+, => jest 검색 => 하단의 Use Jest30을 체크 => vscode reload 하면 해결된다.  
![jest 설정](/assets/images/20250626/jest_setting.png)


## 📚 참고

*   [Testing Overview - Next.js](https://nextjs.org/docs/app/building-your-application/testing/overview)
*   [Testing Library](https://testing-library.com/)
*   [Jest](https://jestjs.io/)
*   [--testPathPattern Parameter](https://stackoverflow.com/questions/77129008/how-can-i-fix-jests-vscode-extensions-testpathpattern-parameter)


